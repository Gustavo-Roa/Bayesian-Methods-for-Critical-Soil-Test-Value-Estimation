---
title: "Estimating Critical Soil Test Values Using Bayesian Model Averaging"
subtitle: "Tutorial in brms and Bridge Sampling"
author: "Gustavo A. Roa"
date: "2026-02-17"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    self-contained: true
execute:
  warning: false
  message: false
---

# Overview
## Purpose

This tutorial demonstrates how to:

\- Fit Bayesian Quadratic-Plateau (B-QP), Linear-Plateau (B-LP), and exponential (B-EXP) response models.

\- Estimate the critical soil test value (CSTV) and its credible interval.

\- Compute marginal likelihoods using bridge sampling.

\- Perform Bayesian model averaging (BMA).

\- Generate model-averaged predictions and uncertainty bands.

The goal is to illustrate how parameter and model uncertainty can be integrated into agronomic threshold estimation.

------------------------------------------------------------------------

# Setup
Loads required packages for Bayesian modeling, marginal likelihood estimation, and data manipulation.
```{r}
# Core packages
library(tidyverse)

# Data I/O
library(readxl)

# Bayesian fitting + marginal likelihood
library(brms)
library(bridgesampling)


```


# Data
## Import data
We import the example phosphorus response dataset.
```{r}

dat <- read_excel("./Data_example.xlsx", sheet = "KS_30")


```

# Bayesian Quadratic Plateau (QP)
The quadratic-plateau model assumes a quadratic increase in yield up to a breakpoint (CSTV) and a constant response beyond that point.
```{r, fig.width=8, fig.height=8}
# brms formula: Bayesian Quadratic Plateau
bf_QP <- brms::bf(response ~  a + b * fmin(input_level, xs) - (b / (2 * xs)) * 
                    fmin(input_level, xs)^2, a + b + xs ~ 1, nl = TRUE)

# Priors (paper-centered)
               # Intercept (B0)
priors_QP <- c(brms::set_prior("normal(58.3, 0.5*58.3)", nlpar = "a", lb = 0),
               # Linear term (B1)
               brms::set_prior("normal(3.8, 0.5*3.8)",  nlpar = "b"),
               # Critical value (xs = theta)
               brms::set_prior("normal(21.4, 0.5*21.4)", nlpar = "xs", lb = 0),
               # Residual SD
               brms::set_prior("student_t(3, 0, 10)", class = "sigma"))

# Fit brms model
fit_QP_bayes <- brms::brm(bf_QP, data = dat, prior = priors_QP, chains = 5, 
                          iter = 3000, warmup = 1000, cores = 1, seed = 555,
                          control = list(adapt_delta = 0.95))

fit_QP_bayes

plot(fit_QP_bayes)

# Extract QP CSTV posterior draws
xs_QP <- brms::as_draws_df(fit_QP_bayes)$b_xs_Intercept

# Posterior median and 95% CrI
xs_QP_hat <- median(xs_QP, na.rm = TRUE)
xs_QP_ci <- quantile(xs_QP, c(0.025, 0.975), na.rm = TRUE)

```

# Bayesian Linear Plateau (LP)
The linear-plateau model assumes a linear increase up to the breakpoint and a constant plateau thereafter.
```{r, fig.width=8, fig.height=8}
# brms formula: Bayesian Linear Plateau
bf_LP <- brms::bf(response ~  a + b * fmin(input_level, xs), 
                  a + b + xs ~ 1, nl = TRUE)

# Priors (paper-centered, Normal, weak)
               # Intercept (B0) 
priors_LP <- c(brms::set_prior("normal(64.5, 0.5*64.5)", nlpar = "a", lb = 0), 
               # Linear term (B1) 
               brms::set_prior("normal(2.25, 0.5*2.25)", nlpar = "b"),
               # Critical value (xs = theta)
               brms::set_prior("normal(15, 0.5*15)", nlpar = "xs", lb = 0),
               # Residual SD
               brms::set_prior("student_t(3, 0, 10)", class = "sigma"))

# Fit brms model
fit_LP_bayes <- brms::brm(bf_LP, data = dat, prior = priors_LP, chains = 5,
                          iter = 3000, warmup = 1000, cores = 1, seed = 555,
                          control = list(adapt_delta = 0.95))

fit_LP_bayes

plot(fit_LP_bayes)

# Extract QP CSTV posterior draws
xs_LP <- brms::as_draws_df(fit_LP_bayes)$b_xs_Intercept

# Posterior median and 95% CrI
xs_LP_hat <- median(xs_LP, na.rm = TRUE)
xs_LP_ci  <- quantile(xs_LP, c(0.025, 0.975), na.rm = TRUE)

```

# Bayesian Mitscherlich (EXP)
This model assumes diminishing returns toward an asymptote. The threshold parameter is defined as the soil test value at which yield reaches 99% of the asymptotic maximum.
```{r, fig.width=8, fig.height=8}
# brms formula: Bayesian Mitscherlich (EXP)
bf_EXP <- brms::bf(response ~ a - b * 
                     exp(-(log(b / (0.01 * a)) / xs) * input_level), 
                   a + b + xs ~ 1, nl = TRUE)

# Priors (paper-centered, Normal, weak)
                # Asymptote
priors_EXP <- c(brms::set_prior("normal(100, 0.5*100)", nlpar = "a", lb = 0), 
                # Yield gap
                brms::set_prior("normal(55, 0.5*55)", nlpar = "b", lb = 0), 
                # Critical STP  
                brms::set_prior("normal(21.4, 0.5*21.4)", nlpar = "xs", lb = 0),  
                # Residual SD  
                brms::set_prior("student_t(3, 0, 10)", class = "sigma"))


fit_EXP_bayes <- brms::brm(bf_EXP, data = dat, prior = priors_EXP, 
                           chains = 5, iter = 3000, warmup = 1000, cores = 1,  
                           seed = 555, control = list(adapt_delta = 0.95))

fit_EXP_bayes

plot(fit_EXP_bayes)

xs_EXP <- brms::as_draws_df(fit_EXP_bayes)$b_xs_Intercept

xs_EXP_hat <- median(xs_EXP, na.rm = TRUE)
xs_EXP_ci  <- quantile(xs_EXP, c(0.025, 0.975), na.rm = TRUE)

xs_EXP_hat
xs_EXP_ci

```



# Model averaging 
Model averaging integrates structural uncertainty across competing response functions.

## Marginal likelihood and posterior model probabilities
\- Bridge sampling estimates marginal likelihood.

\- Posterior model probabilities weight each model.

\- Equal prior model weights are assumed.

```{r}
## Marginal likelihood via bridge sampling
QP_marglog <- bridgesampling::bridge_sampler(fit_QP_bayes, silent = TRUE)
LP_marglog <- bridgesampling::bridge_sampler(fit_LP_bayes, silent = TRUE)
EXP_marglog <- bridgesampling::bridge_sampler(fit_EXP_bayes, silent = TRUE)

## Posterior model probabilities
m_prob <- bridgesampling::post_prob(LP_marglog, QP_marglog, EXP_marglog,
                                    prior_prob = c(1/3, 1/3, 1/3))
w_LP  <- m_prob["LP_marglog"]
w_QP  <- m_prob["QP_marglog"]
w_EXP <- m_prob["EXP_marglog"]

## Extract CSTV (xs) posterior draws
draws_LP <- brms::as_draws_df(fit_LP_bayes)$b_xs_Intercept 
draws_QP <- brms::as_draws_df(fit_QP_bayes)$b_xs_Intercept
draws_EXP <- brms::as_draws_df(fit_EXP_bayes)$b_xs_Intercept

## Align posterior lengths
S <- min(length(draws_LP), length(draws_QP), length(draws_EXP))
```


## Constructing the BMA posterior
We sample breakpoint draws in proportion to posterior model probabilities to obtain a pooled posterior distribution.

```{r}
## Bayesian model averaging
model_ids <- sample(c("LP", "QP", "EXP"), size = S, replace = TRUE, 
                    prob = as.numeric(m_prob))

## Generate BMA posterior draws
theta_bma_bt <- numeric(S)
theta_bma_bt[model_ids == "LP"] <- sample(draws_LP, sum(model_ids == "LP"), 
                                          replace = TRUE)
theta_bma_bt[model_ids == "QP"] <- sample(draws_QP, sum(model_ids == "QP"), 
                                          replace = TRUE)
theta_bma_bt[model_ids == "EXP"] <- sample(draws_EXP, sum(model_ids == "EXP"), 
                                          replace = TRUE)

## BMA point estimate and credible interval
theta_bma_hat <- median(theta_bma_bt, na.rm = TRUE)
theta_bma_ci  <- quantile(theta_bma_bt, c(0.025, 0.975), na.rm = TRUE)

theta_bma_hat
theta_bma_ci

```

## Prediction and Uncertainty
We generate posterior predictive means and credible intervals for each model, then combine them using posterior model weights.
```{r}
# New data for prediction
newdat_BMA <- data.frame(input_level = seq(min(dat$input_level, na.rm = TRUE), 
                                           max(dat$input_level, na.rm = TRUE), 
                                           length.out = 200))

# Make Stan fmin usable in R
fmin <- function(a, b) pmin(a, b)

epred_QP <- posterior_epred(fit_QP_bayes, newdata = newdat_BMA, 
                            re_formula = NA)
epred_LP <- posterior_epred(fit_LP_bayes, newdata = newdat_BMA, 
                            re_formula = NA)
epred_EXP <- posterior_epred(fit_EXP_bayes, newdata = newdat_BMA, 
                             re_formula = NA)


S <- min(nrow(epred_QP), nrow(epred_LP), nrow(epred_EXP))

epred_QP <- epred_QP[seq_len(S), ]
epred_LP <- epred_LP[seq_len(S), ]
epred_EXP <- epred_EXP[seq_len(S), ]

model_ids <- sample(c("LP", "QP", "EXP"), size = S, replace = TRUE, 
                    prob = as.numeric(m_prob))

epred_BMA <- matrix(NA_real_, nrow = S, ncol = ncol(epred_QP))

epred_BMA[model_ids == "QP", ] <-  epred_QP[model_ids == "QP", ]
epred_BMA[model_ids == "LP", ] <-  epred_LP[model_ids == "LP", ]
epred_BMA[model_ids == "EXP", ] <-  epred_EXP[model_ids == "EXP", ]

newdat_BMA$BMA_mean <- colMeans(epred_BMA)
newdat_BMA$BMA_lwr  <- apply(epred_BMA, 2, quantile, 0.025)
newdat_BMA$BMA_upr  <- apply(epred_BMA, 2, quantile, 0.975)

```


# Final Comparison Figure
This figure shows:

\- Observed data

\- Model-averaged mean curve

\- 95% credible band

\- Model-specific CSTV estimates and weights

```{r fig.height=6, fig.width=10}

ggplot() + 
  
  # Observed data
  geom_point(data = dat, aes(x = input_level, y = response), size = 4, 
             alpha = 0.7) +

  # BMA predict
  geom_line(data = newdat_BMA, aes(x = input_level, y = BMA_mean), 
            linewidth = 1.6) +
  geom_ribbon(data = newdat_BMA, aes(x = input_level, ymin = BMA_lwr, 
                                     ymax = BMA_upr), alpha = 0.2) +
  
  # BMA CSTV point and CrI
  geom_point(data = data.frame(x = theta_bma_hat, y = 60), 
             aes(x = x, y = y), 
             size = 5, shape = 17, inherit.aes = FALSE) +
  geom_errorbar(data = data.frame(xmin = theta_bma_ci[1], 
                                  xmax = theta_bma_ci[2], y = 60), 
                aes(xmin = xmin, xmax = xmax, y = y), 
                width = 0.1, linewidth = 1.5, inherit.aes = FALSE) +

  # Single BMA annotation
  annotate("text", x = 20, y = 55,
           label = paste0("BMA: ", round(theta_bma_hat, 0)," (CrI: ", 
                          round(theta_bma_ci[1], 0), ", ", 
                          round(theta_bma_ci[2], 0), ")"),
           size = 6, fontface = "bold") +
  
  # Single QP annotation
  annotate("text", x = 40, y = 50,
           label = paste0("B-QP: ", round(xs_QP_hat, 0)," (CrI: ",
                          round(xs_QP_ci[1], 0), ", ",
                          round(xs_QP_ci[2], 0), "), w = ",
                          round(w_QP, 2)), size = 5) +

  # Single LP annotation
  annotate("text", x = 40, y = 47,
           label = paste0("B-LP: ", round(xs_LP_hat, 0)," (CrI: ",
                          round(xs_LP_ci[1], 0), ", ",
                          round(xs_LP_ci[2], 0), "), w = ",
                          round(w_LP, 2)), size = 5) +

  # Single EXP annotation
  annotate("text", x = 40, y = 44,
           label = paste0("B-EXP: ", round(xs_EXP_hat, 0)," (CrI: ",
                          round(xs_EXP_ci[1], 0), ", ",
                          round(xs_EXP_ci[2], 0), "), w = ",
                          round(w_EXP, 2)), size = 5) +

  
  # Scales and theme
  scale_x_continuous(limits = c(0, 50), breaks = seq(0, 50, 10)) +
  scale_y_continuous(limits = c(40, 100), breaks = seq(40, 100, 10)) +
  
  guides(color = guide_legend(title = NULL)) +
  theme_bw(base_size = 22) +
  theme(panel.grid = element_blank(), axis.text = element_text(color = "black"),
        panel.background = element_rect(color = "black", linewidth = 1.5)) +
  labs(y = "Relative yield (%)", x = expression(Soil~test~P~(mg~kg^-1)))


```


